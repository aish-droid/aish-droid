---
title: "HW-3 Discriminant Analysis code"
output: html_document
date: "2025-02-17"
---
```{r}
library(ggplot2)
library(ggExtra)
library(heplots)
library(lubridate)
library(dplyr)
library(klaR)
library(car)
library(MASS)
library(biotools)
```


```{r}
## importing csv data
library(readxl)

data <- read_excel(r"(C:\Users\Aishwarya Venkat\Documents\Yale\Multivariate Statistics\HW 3 DA\data_trial2.xls)")

head(data)

```

```{r}
data$fem_owner <- as.factor(data$fem_owner)
summary(data[, c("size", "fem_owner", "fem_prodw", "fem_nonprodw")])

```


```{r}
##chi square quantile plots for female production and non production workers - raw data by firm size

# Reset device and adjust margins
par(mfrow = c(1, 3), mar = c(2, 2, 2, 2))  # 1 row, 2 columns, small margins

# Split data by size categories
size_categories <- split(data, data$size)

# Loop through each size category and plot
for (category_name in names(size_categories)) {
  category_data <- size_categories[[category_name]]
  
  # Ensure there are enough data points
  if (nrow(category_data) > 1) {
    cqplot(category_data[, 22:23], 
           main = paste("Size of firm:", category_name), 
           pch = 19, 
           conf = 0.95)
  }
}

# Reset to default layout
par(mfrow = c(1, 1))

```
```{r}
##chi square quantile plots for female production and non production workers - logit transformed by firm size

# Reset device and adjust margins
par(mfrow = c(1, 3), mar = c(2, 2, 2, 2))  # 1 row, 2 columns, small margins

# Split data by size categories
size_categories <- split(data, data$size)

# Loop through each size category and plot
for (category_name in names(size_categories)) {
  category_data <- size_categories[[category_name]]
  
  # Ensure there are enough data points
  if (nrow(category_data) > 1) {
    cqplot(category_data[,28:29], 
           main = paste( "Firm size:", category_name), 
           pch = 19, 
           conf = 0.95)
  }
}

# Reset to default layout
par(mfrow = c(1, 1))
```
```{r}
## attempting chi square quantile plot by firm source for logit transformed sources of working capital by firm sized - does not seem normal, not suitable for DA

# Reset device and adjust margins
par(mfrow = c(1, 3), mar = c(2, 2, 2, 2))  # 1 row, 2 columns, small margins

# Split data by size categories
size_categories <- split(data, data$size)

# Loop through each size category and plot
for (category_name in names(size_categories)) {
  category_data <- size_categories[[category_name]]
  
  # Ensure there are enough data points
  if (nrow(category_data) > 1) {
    cqplot(category_data[,24:27], 
           main = paste( "Firm size:", category_name), 
           pch = 19, 
           conf = 0.95)
  }
}

# Reset to default layout
par(mfrow = c(1, 1))
```


```{r}
# Scatter plot for % of female production vs non-production workers by firm size
plot(data$logi_fem_prodw, data$logi_fem_nonprodw, 
     col = as.numeric(as.factor(data$size)),  # Convert size to numeric for colors
     pch = 19, 
     main = "% Female Workers: Production vs Non-Production", 
     xlab = "% Female Production Workers", 
     ylab = "% Female Non-Production Workers")

# Add legend
legend("topright", 
       col = unique(as.numeric(as.factor(data$size))), 
       legend = unique(data$size), 
       pch = 19, 
       cex = 0.8)  # Adjust text size for readability
```


```{r}
#calculate Box's M statistic
boxM(data[,c("logi_fem_prodw","logi_fem_nonprodw")], data$size)
```
```{r}
## make boxplot categorized by firm size
boxplot(logi_fem_nonprodw ~ size, data=data, col = c("red", "blue"), horizontal = TRUE, 
        main = "log Female Non-Production Workers by Firm Size", 
        ylab = "Firm Size", xlab = "log Female Non-Productive Workers", cex.axis = 0.5)

boxplot(logi_fem_prodw ~ size, data=data, col = c("green", "purple"), horizontal = TRUE, 
        main = "log Female Production Workers by Firm Size", 
        ylab = "Firm Size", xlab = "log Female Productive Workers",cex.axis=0.5)

```
```{r}
#visually compare sample covariance matrices

print("Covariance Matrix for log female workers for small firms")
small_cov <- cov(data[data$size == "Small", 28:29])
print(small_cov)

print("Covariance Matrix for log female workers for medium firms")
med_cov <- cov(data[data$size == "Medium", 28:29])
print(med_cov)

print("Covariance Matrix for log female workers for large firms")
large_cov <- cov(data[data$size == "Large", 28:29])
print(large_cov)
```
```{r}
print("Ratio of Largest to Smallest Covariance Elements")
cov_rat <- small_cov/med_cov
cov_rat[abs(cov_rat) < 1] <- 1/(cov_rat[abs(cov_rat) < 1])
round(cov_rat, 1)

cov_rat <- small_cov/large_cov
cov_rat[abs(cov_rat) < 1] <- 1/(cov_rat[abs(cov_rat) < 1])
round(cov_rat, 1)

cov_rat <- large_cov/small_cov
cov_rat[abs(cov_rat) < 1] <- 1/(cov_rat[abs(cov_rat) < 1])
round(cov_rat, 1)
```
```{r}
scatterplot(logi_fem_prodw ~ logi_fem_nonprodw, data = data, groups = data$size, smooth = F, regLine = F, ellipse = T)

plot1 <- ggplot(data, aes(logi_fem_prodw, logi_fem_nonprodw, colour = size)) + geom_point()
ggMarginal(plot1, groupColour = TRUE, groupFill = TRUE)
```
```{r}
#get univariate and multivariate comparisons
data.manova <- manova(as.matrix(data[,28:29]) ~ data$size)
summary.manova(data.manova, test="Wilks")
```
```{r}
summary.aov(data.manova)
```

```{r}
#SCORE PLOTS for linear DA
sizelda <- lda(scale(data[, c("logi_fem_prodw", "logi_fem_nonprodw")]), grouping = data$size, prior=c((1/3),(1/3),(1/3)))
names(sizelda)
```
```{r}
(data.disc <- sizelda)
```


```{r}
summary(sizelda)
```
```{r}
# Standardize the selected continuous variables
scores <- as.matrix(scale(data[, c("logi_fem_prodw", "logi_fem_nonprodw")])) %*% matrix(sizelda$scaling, ncol = 2)

# Plot the LDA scores
plot(scores[,1], scores[,2], type = "n", main = "Linear DCA scores for data",
     xlab = "DCA Axis 1", ylab = "DCA Axis 2")

# Extract unique group names from 'size' column
group_names <- unique(data$size)

# Assign colors and shapes for plotting
colors <- 2:(length(group_names) + 1)
shapes <- 15:(14 + length(group_names))

# Plot points for each group
for (i in seq_along(group_names)) {
  points(scores[data$size == group_names[i], 1],
         scores[data$size == group_names[i], 2], col = colors[i], pch = shapes[i], cex = 1.1)
}

# Add legend
legend("topright", legend = group_names, col = colors, pch = shapes)


```

```{r}
#####
#THIS PROGRAM CREATES FUNCTIONS TO COMPUTE THE SIGNIFICANCE OF SUCCESSIVE 
#FUNCTIONS IN DISCRIMINANT ANALYSIS WITH MORE THAN 3 GROUPS USING
#SUCCESSIVE WILK'S LAMBDA. IT REQUIRES AS INPUT A MATRIX OF DISCRIMINATORS AND A VECTOR WITH 
#GROUP IDENTIFICATION.
#LDA() FUNCTION.
######



discriminant.significance <- function(DAdata, DAgroup) {

    DA.group <- split(DAdata, DAgroup)
    DA.means <- sapply(DA.group, function(x) {
        apply(x, 2, mean)
    }, simplify = 'data.frame')
    
    DA.size <- sapply(DA.group, function(x) {
        nrow(x)
    }, simplify = 'data.frame')
    
    DA.N <- dim(DAdata)[1]  #Total Sample Size
    DA.p <- dim(DAdata)[2] # Vars
    DA.k <- length(unique(DAgroup))  # Groups
    
    total.means <- colMeans(DAdata)
    num.funcs <- min(length(unique(DAgroup)) - 1, ncol(DAdata))
    
    H <-  matrix(data = NA, nrow = DA.p, ncol = DA.p)
    
    for (i in 1:dim(H)[1]) {
        for (j in 1:i) {
            H[i,j] <- sum(DA.size*((DA.means[i,] - total.means[i]) * (DA.means[j,] - total.means[j])))
            H[j,i] <- sum(DA.size*((DA.means[j,] - total.means[j]) * (DA.means[i,] - total.means[i])))
        }
    }
    E <-  matrix(data = NA, nrow = DA.p, ncol = DA.p)
    for (i in 1:dim(E)[1]) {
        for (j in 1:i) {
            b <- c() 
            for (k in DA.group) {
                a <- sum((k[, i] - mean(k[, i])) * (k[, j] - mean(k[, j])))
                b <- append(b, a)
            }
            E[i,j] <- sum(b)
            E[j,i] <- sum(b)
        }
    }
    
    eigenvalues <- eigen(solve(E) %*% H)$values
  
    w <- DA.N - 1 - .5 * (DA.p + DA.k)
    t <- sqrt((DA.p^2 * (DA.k - 1)^2 - 4) / (DA.p^2 + (DA.k - 1)^2 - 5))
    df1 <- DA.p * (DA.k - 1)
    df2 <- w * t - .5 * (DA.p * (DA.k - 1) - 2)
    lambda1 <- prod(1 / (1 + eigenvalues))
    f1 <- (1 - lambda1^(1/t)) / (lambda1^(1/t)) * df2 / df1
    p1 <- pf(f1, df1, df2, lower.tail = FALSE)
    
    result <- NULL
    for (i in 2:DA.p) {
        m <- i
        
        if (m == DA.p) {
            t.i <- 1
        } else {
            t.i <- sqrt(((DA.p - m + 1)^2 * (DA.k - m)^2 - 4) / ((DA.p - m + 1)^2 + (DA.k - m)^2 - 5))
        }
        
        df1.i <- (DA.p - m + 1) * (DA.k - m)
        df2.i <- w * t.i - .5 * ((DA.p - m + 1) * (DA.k - m) - 2)
        lambda.i <- prod(1 / (1 + eigenvalues[i:DA.p]))
        f.i <- (1 - lambda.i^(1/t.i)) / lambda.i^(1/t.i) * df2.i / df1.i
        p.i <- pf(f.i, df1.i, df2.i, lower.tail = FALSE)
        result <- rbind(result, data.frame(lambda.i, f.i, p.i))
    }
        funlabs <- paste0("1 through ",num.funcs)
    for (i in 2:num.funcs){
        if (i < num.funcs){
            funlabs <- c(funlabs, paste0(i," through ",num.funcs) )
        }
        else{
            funlabs <- c(funlabs, i) 
        }
    }
    res <- cbind(funlabs, rbind(c(lambda1, f1, p1), result))
    for (i in 2:ncol(res)){
        res[, i] <- round(res[, i], 4)
    }
    colnames(res) <- c("Test of Function(s)", "Wilks Lambda", "Approximate F", "p-value")
    return(res)
}



#example
#discriminant.significance(iris[, c("PetShape", "SepShape")], iris$Species)
```


```{r}
#Two inputs required - dataframe with discriminating variabes and vector with group membership
discriminant.significance(as.data.frame(data[, c("logi_fem_prodw", "logi_fem_nonprodw")]), data$size)
```

```{r}
#PLOT Predicted Regions based on two log(shape) variables 
#LDA
data$size <- as.factor(data$size)
partimat(size ~ logi_fem_prodw + logi_fem_nonprodw, data = data, method = "lda")
```

```{r}
(ctraw <- table(data$size, predict(sizelda)$class))
```
```{r}
# total percent correct
round(sum(diag(prop.table(ctraw))), 2)

```
```{r}
dataldaCV <- lda(data[,c("logi_fem_prodw","logi_fem_nonprodw")], grouping = data$size, CV = TRUE)
(ctCV <- table(data$size, dataldaCV$class))
```
```{r}
# total percent correct
round(sum(diag(prop.table(ctCV))), 2)
```
```{r}
library(MASS)
library(plotly)

# Perform kernel density estimation for female production and non-production workers for "Small" category
freqz_small <- with(data.frame(x = data[data$size == "Small",]$fem_prodw, 
                               y = data[data$size == "Small",]$fem_nonprodw),
                     kde2d(x, y, n = 30))

# Perform kernel density estimation for female production and non-production workers for "Medium" category
freqz_medium <- with(data.frame(x = data[data$size == "Medium",]$fem_prodw, 
                                y = data[data$size == "Medium",]$fem_nonprodw),
                      kde2d(x, y, n = 30))

# Perform kernel density estimation for female production and non-production workers for "Large" category
freqz_large <- with(data.frame(x = data[data$size == "Large",]$fem_prodw, 
                               y = data[data$size == "Large",]$fem_nonprodw),
                     kde2d(x, y, n = 30))

# Create plot for "Small" category
plot_small <- plot_ly() %>%
  add_surface(x = freqz_small$x, y = freqz_small$y, z = freqz_small$z, 
              surfacecolor = rep(1, length(freqz_small$z)), colorscale = list(c(0, 1), c('blue', 'blue')),
              opacity = 0.6, showscale = FALSE, name = "Size: Small") %>%
  layout(title = "3D Kernel Density Estimation: Female Production vs Non-Production (Small)",
         scene = list(xaxis = list(title = "% Female Production Workers"),
                      yaxis = list(title = "% Female Non-Production Workers"),
                      zaxis = list(title = "Density")))

# Create plot for "Medium" category
plot_medium <- plot_ly() %>%
  add_surface(x = freqz_medium$x, y = freqz_medium$y, z = freqz_medium$z, 
              surfacecolor = rep(1, length(freqz_medium$z)), colorscale = list(c(0, 1), c('green', 'green')),
              opacity = 0.6, showscale = FALSE, name = "Size: Medium") %>%
  layout(title = "3D Kernel Density Estimation: Female Production vs Non-Production (Medium)",
         scene = list(xaxis = list(title = "% Female Production Workers"),
                      yaxis = list(title = "% Female Non-Production Workers"),
                      zaxis = list(title = "Density")))

# Create plot for "Large" category
plot_large <- plot_ly() %>%
  add_surface(x = freqz_large$x, y = freqz_large$y, z = freqz_large$z, 
              surfacecolor = rep(1, length(freqz_large$z)), colorscale = list(c(0, 1), c('red', 'red')),
              opacity = 0.6, showscale = FALSE, name = "Size: Large") %>%
  layout(title = "3D Kernel Density Estimation: Female Production vs Non-Production (Large)",
         scene = list(xaxis = list(title = "% Female Production Workers"),
                      yaxis = list(title = "% Female Non-Production Workers"),
                      zaxis = list(title = "Density")))

# Display the plots
plot_small
plot_medium
plot_large

```


```{r}
library(MASS)
library(plotly)

# Perform kernel density estimation for female production and non-production workers for "Small" category
freqz_small <- with(data.frame(x = data[data$size == "Small",]$fem_prodw, 
                               y = data[data$size == "Small",]$fem_nonprodw),
                     kde2d(x, y, n = 30))

# Perform kernel density estimation for female production and non-production workers for "Medium" category
freqz_medium <- with(data.frame(x = data[data$size == "Medium",]$fem_prodw, 
                                y = data[data$size == "Medium",]$fem_nonprodw),
                      kde2d(x, y, n = 30))

# Perform kernel density estimation for female production and non-production workers for "Large" category
freqz_large <- with(data.frame(x = data[data$size == "Large",]$fem_prodw, 
                               y = data[data$size == "Large",]$fem_nonprodw),
                     kde2d(x, y, n = 30))

# Create combined plot
plot <- plot_ly() %>%
  add_surface(x = freqz_small$x, y = freqz_small$y, z = freqz_small$z, 
              surfacecolor = rep(1, length(freqz_small$z)), colorscale = list(c(0, 1), c('blue', 'blue')),
              opacity = 0.6, showscale = FALSE, name = "Size: Small") %>%
  add_surface(x = freqz_medium$x, y = freqz_medium$y, z = freqz_medium$z, 
              surfacecolor = rep(1, length(freqz_medium$z)), colorscale = list(c(0, 1), c('green', 'green')),
              opacity = 0.6, showscale = FALSE, name = "Size: Medium") %>%
  add_surface(x = freqz_large$x, y = freqz_large$y, z = freqz_large$z, 
              surfacecolor = rep(1, length(freqz_large$z)), colorscale = list(c(0, 1), c('red', 'red')),
              opacity = 0.6, showscale = FALSE, name = "Size: Large") %>%
  
  # Adding a dummy scatter trace to act as a legend
  add_trace(type = "scatter", mode = "markers", x = c(NA), y = c(NA), 
            marker = list(color = 'blue', size = 10), name = "Size: Small") %>%
  add_trace(type = "scatter", mode = "markers", x = c(NA), y = c(NA), 
            marker = list(color = 'green', size = 10), name = "Size: Medium") %>%
  add_trace(type = "scatter", mode = "markers", x = c(NA), y = c(NA), 
            marker = list(color = 'red', size = 10), name = "Size: Large") %>%
  
  layout(title = "3D Kernel Density Estimation: Female Production vs Non-Production Workers",
         scene = list(xaxis = list(title = "% Female Production Workers"),
                      yaxis = list(title = "% Female Non-Production Workers"),
                      zaxis = list(title = "Density")),
         legend = list(title = list(text = "Firm Size")))

# Show the combined plot
plot

```

```{r}
library(plotly)

# Convert size to a factor with meaningful labels
data$size <- factor(data$size, levels = c("Small", "Medium", "Large"))

# Define variables
x <- data$fem_prodw
y <- data$fem_nonprodw
color_var <- data$size  # Use labeled factor for coloring

# Define custom color scales
contour_colors <- list(
  list(0, "blue"),   # Small
  list(0.5, "green"),   # Medium
  list(1, "red")    # Large
)

# Create subplot with colored distributions
s <- subplot(
  plot_ly(x = x, type = "histogram", color = color_var, showlegend = TRUE) %>% 
    layout(bargap = 0.1),
  plotly_empty(),
  plot_ly(x = x, y = y, type = "histogram2dcontour", 
          z = as.numeric(color_var) - 1,  # Convert factor to numeric
          colorscale = contour_colors, 
          showscale = FALSE,
          nbinsx = 7,  # Increase for finer resolution, decrease for smoother contours
          nbinsy = 7), # Adjust similarly
  plot_ly(y = y, type = "histogram", color = color_var, showlegend = FALSE) %>% 
    layout(bargap = 0.1),
  nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2),
  shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE
) 

layout(s)

```




